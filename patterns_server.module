<?php
/**
 * @file
 * Patterns Server module.
 *
 * the module'name is patterns_server.
 */

module_load_include('inc', 'patterns_server', 'includes/variables');
module_load_include('inc', 'patterns_server', 'includes/db');
module_load_include('inc', 'patterns_server', 'includes/io');
module_load_include('inc', 'patterns_server', 'theme/theme');
module_load_include('inc', 'patterns_server', 'includes/utils');

/**
 * Implements hook_help().
 */
function patterns_server_help($path, $arg) {
  switch ($path) {
    case "admin/help#patterns_server":
      return '<p>' . t("help for patterns_server module") . '<p>';
      break;
  }
}

/**
 * Implements hook_permission().
 */
function patterns_server_permission() {
  return array(
    'access patterns_server' => array(
      'title' => t('Access permission for the patterns_server module'),
    ),
    'post patterns' => array(
      'title' => t('Post patterns through REST api'),
    ),
    'update patterns' => array(
      'title' => t('Update patterns through REST api'),
    ),
  );
}

/**
 * Implements hook_menu().
 *
 * the path'callback function is _patterns_server_page().
 * second: configure form page.
 */
function patterns_server_menu() {
  $items = array();
  $allow_pulbish = variable_get('patterns_allow_publish', PATTERNS_ALLOW_PUBLISH_DEFAULT);
  if (patterns_utils_is_public_page_enabled() && $allow_pulbish) {
    $public_link = variable_get('patterns_public_url', '');
    $items[$public_link] = array(
      'title' => $public_link,
      'page callback' => '_patterns_server_page',
      'access arguments' => array('access patterns_server'),
      //'type' => MENU_NORMAL_ITEM,
      'type' => MENU_LOCAL_TASK,
    );

    $search_link = $public_link . "/search/%";
    $items[$search_link] = array(
      'title' => 'Search',
      'page callback' => '_patterns_search_page',
      'page arguments' => array(2),
      'access arguments' => array('access patterns_server'),
      'access callback' => TRUE,
      'type' =>  MENU_CALLBACK,
    );


    /* this used for user search the categoried patterns

         $items['patterns_server/category'] = array(
              'title' => 'Patterns Server search category',
            'page callback' => 'patterns_server_pattern_category_page',
            'access arguments' => array('access patterns_server'),
            'type' => MENU_NORMAL_ITEM,
           );
     */

    $post_link = $public_link . "/post";
    $items[$post_link] = array(
      'title' => 'patterns_server',
      'page callback' => 'patterns_server_incoming_patterns',
      'access arguments' => array('post patterns'),
      'type' => MENU_CALLBACK,
    );

    $download_link = $public_link . "/download";
    $items[$download_link] = array(
      'title' => 'Download Pattern Source',
      'page callback' => 'patterns_server_download',
      'access arguments' => array('get patterns'),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );

    $liked_link = $public_link . "/like";
    $items[$liked_link] = array(
      'title' => 'Rate certain Pattern',
      'page callback' => 'patterns_server_like',
      'access arguments' => array('get patterns'),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );

    $info_link = $public_link . "/info";
    $items[$info_link] = array(
      'title' => 'Information of one pattern',
      'page callback' => 'patterns_server_pattern_info',
      'access arguments' => array('get patterns'),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );
  }
  return $items;
}

/* this used for user search the categoried patterns
function patterns_server_get_category_patterns_from_db($category_name){
          $result = db_select('patterns', 'p')
                   ->fields('p', array())
                   ->condition('p.category', $category_name)
                   ->execute()
                   ->fetchAll();
        return $result;

}

function patterns_server_get_category_list(){
    $result = db_select('taxonomy_term_data','t')
				->field('t',array('name'))
				->execute()
				->fetchAllKeyed();
	return $result;


//	$result = entity_load('taxonomy_term');
//	$node = db_fetch_object($terms);
//	$vid = $node->vid;

	$items = array();
//	$terms = taxonomy_get_tree($vid);
//	   foreach ($terms as $term) {
//	   		$count = taxonomy_term_count_nodes($term->tid);
//			 if ($count) {
//	   		$items[$term->tid] = $term ->name;
//	   }
	// $category_list = array_unique($result);
}*/

/**
 */
function patterns_server_search_form($form, &$form_state, $args='') {
  $search_type = NULL;
  $search_content = NULL;
  if (!empty($args)) {
    $search_type = substr($args, 0, 1);
    $search_content = substr($args, 2);
  }
  $form['patterns_search']= array(
    '#type' => 'container',
    '#attributes' => array('class' => array('container-inline')),

  );
  $form['patterns_search']['search'] = array(
    '#type' => 'textfield',
    '#title' => t('Search'),
    '#title_display' => 'invisible',
    '#size' => 15,
    '#default_value' => ($args == '')?'':$search_content ,
    '#attributes' => array('title' => t('Enter the terms you wish to search for.'), 'class' => array('container-inline')),

  );
  $form['patterns_search']['selected'] = array(
    '#type' => 'select',
    '#title' => t('Selected'),
    '#title_display' => 'invisible',
    '#options' => array(
      0 => t('Title'),
      1 => t('Description'),
      2 => t('Author'),
      3 => t('UUID'),
      4 => t('Pid'),
    ),
    '#default_value' => ($args == '')?0:$search_type,
  );

  $form['patterns_search']['actions'] = array('#type' => 'actions');
  $form['patterns_search']['actions']['submit'] = array('#type' => 'submit', '#value' => t('Search'));
  $form['patterns_search']['#submit'][] = 'patterns_server_search_form_submit';

  return $form;
}

/**
 */
function patterns_server_search_form_submit($form, &$form_state) {

  if ($form_state['values']['search'] == '') {
    form_set_error('keys', t('Please enter some keywords.'));
  }

  $form_id = $form['form_id']['#value'];
  $form_state['redirect'] = variable_get('patterns_public_url', '') . '/search/' . trim($form_state['values']['selected']) . '_' . trim($form_state['values']['search']);

}

/**
 */
function patterns_server_comment_form($form, &$form_state, $args='') {

  $form['patterns_comment']= array(
    '#type' => 'container',
    '#attributes' => array('class' => array('container-inline')),

  );
  $form['patterns_comment']['comment'] = array(
    '#type' => 'textarea',
    '#title' => t('comment'),
    '#title_display' => 'invisible',
    '#cols' => 60,
    '#rows' => 5,
    //'#default_value' => $args['nihao'],
    '#attributes' => array('title' => t('Enter the terms you wish to comment .'), 'class' => array('container-inline')),
  );
  $form['patterns_comment']['pid'] = array('#type' => 'value', '#value' => $args['pid']);
  $form['patterns_comment']['actions'] = array('#type' => 'actions');
  $form['patterns_comment']['actions']['submit'] = array('#type' => 'submit', '#value' => t('Comment'));
  $form['patterns_comment']['#submit'][] = 'patterns_server_comment_form_submit';

  return $form;
}

/**
 */
function patterns_server_comment_form_submit($form, &$form_state) {

  global $user;
  if ($form_state['values']['comment'] == '') {
    form_set_error('comments', t('Please enter some comment.'));
    return;
  }
  $form_state['values']['comment'] = check_plain($form_state['values']['comment']);
    db_insert('patterns_comments')
      ->fields(array( 'pid' => $form_state['values']['pid'], 'uid' => $user->uid, 'created' => time(), 'comment_content' => $form_state['values']['comment']))
      ->execute();
  global $base_url;
  $public_link = variable_get('patterns_public_url', '');
  drupal_goto($base_url . '/' . $public_link . '/info/' . $form_state['values']['pid']);
}

/* used for catrgory list

   function patterns_server_search_category_form($form, &$form_state,$args='') {

    $form['patterns_category_search'] = array(
			    '#type' => 'select',
			    '#title' => t('Select a category'),
				'#title_display' => 'invisible',
			    '#id' = 'patterns_category_search',
				'options' => patterns_server_get_category_list(),
									  );
   $form['actions'] = array('#type' => 'actions');
	    return $form;
		}
 */

/**
 * hook_menu callback function.
 */
function _patterns_server_page() {
  drupal_add_js(drupal_get_path('module', 'patterns_server') . '/js/patterns_server_page.js');
  $page = NULL;

  //first part: search box and patterns list.
  $result = patterns_server_get_pattern_from_db(10);
  $page .= theme('patterns_server_pattern_list', array(
                    'patterns' => $result,
  ));

  //second part: one pattern's information.
  $result = patterns_server_get_pattern_from_db(1);
  $page .= theme('patterns_server_one_pattern_info', array(
                    'patterns' => $result,
  ));
  //print_r(variable_get('patterns_public_url', ''));
  return $page;
}

/**
 * hook_menu callback function.
 */
function _patterns_search_page($keys) {
  $search_type = substr($keys, 0, 1);
  $search_content = substr($keys, 2);
  $result = patterns_server_search_pattern($search_content, $search_type);
  $page_array = theme('patterns_server_pattern_list', array(
                    'patterns' => $result,
                    'searchkey' => $keys,
  ));

  $page_array .= '<div id="one_pattern_div"></div>';
  return $page_array;
}

/**
 */
function patterns_server_pattern_download($file, $filename) {
  drupal_add_http_header("Content-type", " text/plain; charset=utf-8");
  drupal_add_http_header("Content-Disposition", "attachment;filename=" . $filename);
  print $file;
  exit;
}

/**
 */
function patterns_server_download_recode($id) {
  $download_origin_times = db_select('patterns_server', 'ps')
    ->fields('ps', array('downloadnum', 'pid'))
    ->condition('pid', $id)
    ->execute()
    ->fetchAssoc();
  if (empty($download_origin_times['pid'])) {
    db_insert('patterns_server')
      ->fields(array( 'pid' => $id, 'downloadnum' => 1, 'liked' => 0))
      ->execute();
  }
  else {
    $download_origin_times['downloadnum']  += 1;
    db_update('patterns_server')
      ->condition('pid', $id)
      ->fields(array('downloadnum' => $download_origin_times['downloadnum']))
      ->execute();
  }
}

/**
 */
function patterns_server_download($id) {
  $result = patterns_server_get_pattern_pid_from_db($id);
  $result[0]->pattern = unserialize($result[0]->pattern);
  patterns_server_download_recode($id);
  patterns_server_pattern_download(file_get_contents($result[0]->file), $result[0]->name);
  exit;
}

/**
 */
function patterns_server_like($id) {
  global $user;
  $liked_origin = db_select('patterns_liked', 'pr')
    ->fields('pr', array('liked', 'pid', 'uid'))
    ->condition('pid', $id)
    ->condition('uid', $user->uid)
    ->execute()
    ->fetchAssoc();
  if (empty($liked_origin['pid'])) {
    db_insert('patterns_liked')
      ->fields(array( 'pid' => $id, 'uid' => $user->uid, 'liked' => 1, 'created' => time()))
      ->execute();
    $liked_origin = db_select('patterns_server', 'ps')
      ->fields('ps', array('liked', 'pid'))
      ->condition('pid', $id)
      ->execute()
      ->fetchAssoc();
    if (empty($liked_origin['pid'])) {
      db_insert('patterns_server')
      ->fields(array( 'pid' => $id, 'downloadnum' => 0, 'liked' => 1, ))
      ->execute();
    }
    else {
      $liked_origin['liked']  += 1;
      db_update('patterns_server')
      ->condition('pid', $id)
      ->fields(array('liked' => $liked_origin['liked']))
      ->execute();
    }
  }
  else {
    db_delete('patterns_liked')
      ->condition('pid', $id)
      ->condition('uid', $user->uid)
      ->execute();
    $liked_origin = db_select('patterns_server', 'ps')
      ->fields('ps', array('liked', 'pid'))
      ->condition('pid', $id)
      ->execute()
      ->fetchAssoc();
    $liked_origin['liked']  -= 1;
    db_update('patterns_server')
      ->condition('pid', $id)
      ->fields(array('liked' => $liked_origin['liked']))
      ->execute();
  }
  $public_link = variable_get('patterns_public_url', '');
  $info_link_id = $public_link . "/info/" . $id;
  drupal_goto($info_link_id);
}

/**
 */
function patterns_server_pattern_info($id) {
  $result = patterns_server_get_pattern_from_db($id, FALSE);
  $page = theme('patterns_server_one_pattern_info', array(
                    'patterns' => $result,
  ));
  return $page;
}

/**
  function _patterns_server_pattern_category_page($category_name) {
      drupal_add_css(drupal_get_path('module', 'patterns_server') . '/patterns_server.css');
      $result = patterns_server_get_category_patterns_from_db($category_name);
      $page = theme('patterns_server_one_pattern_info',array(
                       'patterns' => $result,
      ));

 */

/**
 * Implements hook_xmlrpc().
 *
 * Provides Drupal with an array to map XML-RPC callbacks to existing functions.
 * These functions may be defined in other modules. The example implementation
 * defines specific functions for the example services.
 *
 * Note: Drupal's built-in XML-RPC server already includes several methods by
 * default:
 *
 * Service dicovery methods:
 * - system.listMethods: return a list of the methods the server has, by name.
 * - system.methodSignature: return a description of the argument format a
 * - system.methodHelp: returns a text description of a particular method.
 *   particular method expects.
 *
 * Other:
 * - system.multicall: perform several method calls in a single xmlrpc request.
 * - system.getCapabilities: determine if a given capability is supported.
 *
 * The methods defined by hook_xmlrpc() will be added to those provided by
 * default by Drupal's XML-RPC server.
 *
 * @see hook_xmlrpc()
 */
function patterns_server_xmlrpc() {
  $methods[] = array(
      // First argument is the method name.
      'patterns_server.get_patterns_list',
      // Callback to execute when this method is requested.
      '_patterns_server_get_patterns_list',
      // An array defines the types of output and input values for this method.
      array(
          // The first value is the return type, an array in this case.
          'struct',
          // First operand is an integer (max number of patterns)
          'int',
      ),
      // Include a little description that is shown when XML-RPC server is
      // requested for the implemented methods list.
      // Method description.
      t('Returns the list of patterns available in this server. The argument is the max number of patterns to receive.'),
  );
  return $methods;
}

// The following code for the server is optional if the callbacks already exist.
// A server may implement methods associated to callbacks like node_load(),
// variable_get() or any other existing function (php functions as well).
//
// If the callbacks associated to the methods don't exist they must be
// created. This implementation requires two specific callbacks:
// - _xmlrpc_example_server_add()
// - _xmlrpc_example_server_subtract()
//
//
/**
 * This is the callback for the xmlrpc_example.add method.
 *
 * Sum the two arguments and return value or an error if the result is out of
 * the configured limits.
 *
 * @param $num1
 *   The first number to be summed.
 * @param $num2
 *   The second number to be summed.
 *
 * @return
 *   The sum of the arguments, or error if it is not in server defined bounds.
 *
 * @see xmlrpc_error()
 */
function _patterns_server_get_patterns_list($limit) {
  //return xmlrpc_error(10002, t('Result is below the lower limit defined by the server (@min).', array('@min' => $min)));

  //@TO-DO: Perform the real query
  $patterns_list = array('uuid'=> '12346', 'desc' => 'blah blah blah', 'url' => '/patatin/patatan');
  return $patterns_list;
}
